{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;EAcE","sourcesContent":["/*!\r\n   Copyright 2019 Ron Buckton\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n\r\n/// <reference lib=\"es2018.asynciterable\" />\r\n\r\n/** A type useful as a base constraint for a string that should be inferred as a string literal type. */\r\nexport type conststring = string & {} | \"\";\r\n\r\n/** A type useful as a base constraint for a number that should be inferred as a number literal type. */\r\nexport type constnumber = number & {} | 0;\r\n\r\n/** A type useful as a base constraint for a symbol that should be inferred as a unique symbol type. */\r\nexport type constsymbol = symbol & {} | typeof kIgnore;\r\ndeclare const kIgnore: unique symbol;\r\n\r\n/** A type useful as a base constraint for an array that should be inferred as a tuple. */\r\nexport type consttuple<T> = readonly T[] | readonly [];\r\n\r\ntype numbers255 = [\r\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\r\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\r\n    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\r\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\r\n    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\r\n    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\r\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\r\n    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\r\n    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\r\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\r\n    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\r\n    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\r\n    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\r\n    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\r\n    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\r\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\r\n];\r\n\r\ntype strings255 = numbers255 extends infer T ? { [P in keyof T]: P } : never;\r\n\r\n/**\r\n * Gets a union of the number and numeric string value for a number or numeric string index between 0 and 255\r\n */\r\nexport type numstr<I extends keyof any> =\r\n    I extends numbers255[number] ? I | strings255[I] :\r\n    I extends strings255[number] ? I | numbers255[I] :\r\n    never;\r\n\r\n/**\r\n * A union of all of the primitive types in TypeScript.\r\n */\r\nexport type Primitive = string | symbol | boolean | number | bigint;\r\n\r\n/**\r\n * A union of all of the falsy types in TypeScript.\r\n */\r\nexport type Falsy = null | undefined | false | 0 | 0n | '';\r\n\r\n/** @deprecated Use {@link Falsy} instead. */\r\nexport type Falsey = Falsy;\r\n\r\n/**\r\n * A PropertyDescriptor constrained to the valid attributes for an accessor.\r\n */\r\nexport interface AccessorPropertyDescriptor<T = any> {\r\n    enumerable?: boolean;\r\n    configurable?: boolean;\r\n    get?(): T;\r\n    set?(v: T): void;\r\n}\r\n\r\n/**\r\n * A PropertyDescriptor constrained to the valid attributes for a method.\r\n */\r\nexport interface MethodPropertyDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> {\r\n    enumerable?: boolean;\r\n    configurable?: boolean;\r\n    writable?: boolean;\r\n    value: T;\r\n}\r\n\r\n/**\r\n * Indicates a type that may be `undefined`.\r\n */\r\nexport type Optional<T> = T | undefined;\r\n\r\n/**\r\n * Strips `undefined` from a type.\r\n */\r\nexport type NonOptional<T> = T extends undefined ? never : T;\r\n\r\n/**\r\n * Indicates a type that may be `null` or `undefined`.\r\n */\r\nexport type Nullable<T> = T | undefined | null;\r\n\r\n/**\r\n * Strips `null` or `undefined` from a type.\r\n */\r\nexport import NonNullable = globalThis.NonNullable;\r\n\r\n/**\r\n * Gets a union of `keyof T'` of each constituent `T'` of `T`.\r\n */\r\nexport type AnyKeyof<T> = T extends unknown ? keyof T : never;\r\n\r\n/**\r\n * Gets a union of `Extract<T', U>` for each constituent `T'` of `T`.\r\n */\r\nexport type AnyExtract<T, U> = T extends unknown ? Extract<T, U> : never;\r\n\r\n/**\r\n * Gets a union of `Exclude<T', U>` for each constituent `T'` of `T`.\r\n */\r\nexport type AnyExclude<T, U> = T extends unknown ? Exclude<T, U> : never;\r\n\r\n/**\r\n * Represents a concrete ECMAScript constructor object.\r\n */\r\nexport type Constructor<T = {}, A extends any[] = any[]> = new (...args: A) => T;\r\n\r\n/**\r\n * Represents an abstract class constructor.\r\n */\r\nexport type AbstractConstructor<T = {}, A extends any[] = any[]> = abstract new (...args: A) => T;\r\n\r\n/**\r\n * Gets the type yielded by an Iterable.\r\n */\r\nexport type IteratedType<T> =\r\n    T extends { [Symbol.iterator](): { next(...args: any): infer R } } ?\r\n        R extends { done?: boolean, value: any } ?\r\n            R[\"done\"] extends true ? never : R[\"value\"] :\r\n            never :\r\n        never;\r\n\r\n/**\r\n * Gets the type that can be returned from a generator when it has finished executing.\r\n */\r\nexport type GeneratorReturnType<T> =\r\n    T extends { [Symbol.iterator](): { next(...args: any): infer R } } ?\r\n        R extends { done?: boolean, value: any } ?\r\n            R[\"done\"] extends false | undefined ? never : R[\"value\"] :\r\n            never :\r\n        never;\r\n\r\n/**\r\n * Gets the type that can be sent to a generator via its `next` method.\r\n */\r\nexport type GeneratorNextType<T> =\r\n    T extends { [Symbol.iterator](): { next(value?: infer U): any } } ? U :\r\n    never;\r\n\r\n/**\r\n * Gets the type yielded by an AsyncIterable.\r\n */\r\nexport type AsyncIteratedType<T> =\r\n    T extends { [Symbol.asyncIterator](): { next(...args: any): PromiseLike<infer R> } } ?\r\n        R extends { done?: boolean, value?: any } ?\r\n            R[\"done\"] extends true ? never : Await<R[\"value\"]> :\r\n            never :\r\n        never;\r\n\r\n/**\r\n * Gets the type that can be sent to a generator via its `next` method.\r\n */\r\nexport type AsyncGeneratorNextType<T> =\r\n    T extends { [Symbol.asyncIterator](): { next(value?: infer U): any } } ? U :\r\n    never;\r\n\r\n/**\r\n * Gets the type that can be returned from a generator when it has finished executing.\r\n */\r\nexport type AsyncGeneratorReturnType<T> =\r\n    T extends { [Symbol.asyncIterator](): { next(...args: any): PromiseLike<infer R> } } ?\r\n        R extends { done?: boolean, value?: any } ?\r\n            R[\"done\"] extends false | undefined ? never : Await<R[\"value\"]> :\r\n            never :\r\n        never;\r\n\r\n/**\r\n * Gets the promised type of a Promise.\r\n */\r\nexport type PromisedType<T> =\r\n    T extends { then(onfulfilled: infer U): any } ? U extends ((value: infer V) => any) ? V : never :\r\n    never;\r\n\r\n/**\r\n * Maps an ordered tuple of types into an intersection of those types.\r\n */\r\nexport type Intersection<A extends any[]> =\r\n    A extends [infer H, ...infer T] ? H & Intersection<T> :\r\n    unknown;\r\n\r\n/**\r\n * Maps an ordered tuple of types into a union of those types.\r\n */\r\nexport type Union<A extends any[]> = A[number];\r\n\r\n// TODO(rbuckton): Investigate whether UnionToIntersection should be kept. Intersections are ordered\r\n//                 while unions are unordered.\r\n// /**\r\n//  * Maps a union of types into an intersection of types.\r\n//  */\r\n// export type UnionToIntersection<U> = ((U extends unknown ? (u: U) => void : never) extends ((i: infer I) => void) ? I : never) | never;\r\n\r\n/**\r\n * Maps to `true` if `A` is precisely the `any` type; otherwise, `false`.\r\n */\r\nexport type IsAny<A> = (1 | 2) extends (A extends never ? 1 : 2) ? true : false;\r\n\r\n/**\r\n * Maps to `true` if `A` is precisely the `never` type; otherwise, `false`.\r\n */\r\nexport type IsNever<A> = (A extends never ? true : false) extends true ? true : false;\r\n\r\n/**\r\n * Maps to `true` if `A` is precisely the `unknown` type; otherwise, `false`.\r\n */\r\nexport type IsUnknown<A> =\r\n    IsAny<A> extends true ? false :\r\n    unknown extends A ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if `T` is a union of multiple types; otherwise, `false`.\r\n */\r\nexport type IsUnion<T> =\r\n    IsNever<T> extends true ? false :\r\n    __IsUnionRest<T, [T]>;\r\n\r\ntype __IsUnionRest<T, Q> = T extends unknown ? Not<SameType<[T], Q>> : never;\r\n\r\n/**\r\n * Maps to `true` if `Sub` is a subtype of `Super`; otherwise, `false`.\r\n */\r\nexport type IsSubtypeOf<Sub, Super> =\r\n    IsNever<Super> extends true ? IsNever<Sub> :\r\n    IsNever<Sub> extends true ? true :\r\n    IsAny<Super> extends true ? true :\r\n    IsAny<Sub> extends true ? true :\r\n    Sub extends Super ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if `Super` is a supertype of `Sub`; otherwise, `false`.\r\n */\r\nexport type IsSupertypeOf<Super, Sub> = IsSubtypeOf<Sub, Super>;\r\n\r\n/**\r\n * Maps to `true` if the type has a call signature; otherwise, `false`.\r\n */\r\nexport type IsCallable<T> =\r\n    IsAny<T> extends true ? boolean :\r\n    IsNever<T> extends true ? never :\r\n    SameType<T, Function> extends true ? true :\r\n    [T] extends [(...args: any) => any] ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if the type has a construct signature; otherwise, `false`.\r\n */\r\nexport type IsConstructable<T> =\r\n    IsAny<T> extends true ? boolean :\r\n    IsNever<T> extends true ? never :\r\n    SameType<T, Function> extends true ? true :\r\n    [T] extends [new (...args: any) => any] ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if `A` is `false`, otherwise `true`.\r\n */\r\nexport type Not<A extends boolean> =\r\n    IsNever<A> extends true ? never :\r\n    A extends false ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if both `A` and `B` are `true`; otherwise, `false`.\r\n */\r\nexport type And<A extends boolean, B extends boolean> =\r\n    IsNever<A> extends true ? never :\r\n    IsNever<B> extends true ? never :\r\n    A extends false ? false :\r\n    B extends false ? false :\r\n    true;\r\n\r\n/**\r\n * Maps to `true` if either `A` or `B` are `true`; otherwise, `false`.\r\n */\r\nexport type Or<A extends boolean, B extends boolean> =\r\n    IsNever<A> extends true ? never :\r\n    IsNever<B> extends true ? never :\r\n    A extends true ? true :\r\n    B extends true ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if only one of either `A` or `B` are `true`; otherwise, `false`.\r\n */\r\nexport type XOr<A extends boolean, B extends boolean> =\r\n    IsNever<A> extends true ? never :\r\n    IsNever<B> extends true ? never :\r\n    A extends true ? Not<B> :\r\n    B extends true ? Not<A> :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if every element of the tuple `L` is `true`; otherwise, `false`.\r\n */\r\nexport type Every<L extends boolean[]> =\r\n    L extends [] ? never :\r\n    __EveryRest<{\r\n        [P in keyof L]:\r\n            IsNever<L[P]> extends true ? \"never\" :\r\n            IsAny<L[P]> extends true ? \"boolean\" :\r\n            boolean extends L[P] ? \"boolean\" :\r\n            L[P] extends false ? \"false\" :\r\n            never;\r\n    }[number]>;\r\n\r\ntype __EveryRest<R> =\r\n    \"never\" extends R ? never : // an element was `never`\r\n    \"false\" extends R ? false : // at least one element was `false`\r\n    \"boolean\" extends R ? boolean : // an element was `any` or `boolean`\r\n    true; // no elements were false\r\n\r\n/**\r\n * Maps to `true` if any element of the tuple `L` is `true`; otherwise, `false`.\r\n */\r\nexport type Some<L extends boolean[]> = L extends [] ? never : __SomeRest<{\r\n    [P in keyof L]:\r\n        IsNever<L[P]> extends true ? \"never\" :\r\n        IsAny<L[P]> extends true ? \"boolean\" :\r\n        boolean extends L[P] ? \"boolean\" :\r\n        L[P] extends true ? \"true\" :\r\n        never;\r\n}[number]>;\r\n\r\ntype __SomeRest<R> =\r\n    \"never\" extends R ? never : // an element was `never`\r\n    \"true\" extends R ? true : // at least one element was `true`\r\n    \"boolean\" extends R ? boolean : // an element was `any` or `boolean`\r\n    false; // no elements were true\r\n\r\n/**\r\n * Maps to `true` if exactly one element of the tuple `L` is `true`; otherwise, `false`.\r\n */\r\nexport type One<L extends boolean[]> = L extends [] ? never : __OneRest<{\r\n    [P in keyof L]:\r\n        IsNever<L[P]> extends true ? \"never\" :\r\n        IsAny<L[P]> extends true ? \"boolean\" :\r\n        boolean extends L[P] ? \"boolean\" :\r\n        L[P] extends true ? [P] :\r\n        never;\r\n}[number]>;\r\n\r\ntype __OneRest<R> =\r\n    \"never\" extends R ? never : // an element was `never`\r\n    \"boolean\" extends R ? boolean : // an element was `any` or `boolean`\r\n    IsNever<R> extends true ? false : // no elements were `true`\r\n    IsUnion<R> extends true ? false : // multiple elements were `true`\r\n    true; // only one element was `true`\r\n\r\n/**\r\n * Maps to `true` if both `A` and `B` are assignable to each other; otherwise, `false`.\r\n */\r\nexport type SameType<A, B> =\r\n    IsNever<A> extends true ? IsNever<B> :\r\n    IsNever<B> extends true ? false :\r\n    [A, B] extends [B, A] ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if all elements of the tuple `L` are assignable to each other; otherwise, `false`.\r\n */\r\nexport type SameTypes<L extends any[]> =\r\n    L extends [] ? never :\r\n    SameType<{ [P in keyof L]: SameType<L[P], L[number]> }[number], true>;\r\n\r\n/**\r\n * Maps to `true` if either `A` or `B` are relatable to each other.\r\n */\r\nexport type Relatable<A, B> =\r\n    IsNever<A> extends true ? false :\r\n    IsNever<B> extends true ? false :\r\n    IsAny<A> extends true ? true :\r\n    IsAny<B> extends true ? true :\r\n    [A] extends [B] ? true :\r\n    [B] extends [A] ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if any type in `A` is assignable to any type in `B`; otherwise, `false`.\r\n */\r\nexport type Overlaps<A, B> =\r\n    IsNever<A> extends true ? false :\r\n    IsNever<B> extends true ? false :\r\n    IsAny<A> extends true ? true :\r\n    IsAny<B> extends true ? true :\r\n    1 extends (A extends unknown ? A extends B ? 1 : 2 : 3) ? true :\r\n    1 extends (B extends unknown ? B extends A ? 1 : 2 : 3) ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if `Sub` is a subset of `Super`; otherwise, `false`.\r\n */\r\nexport type IsSubsetOf<Sub, Super> =\r\n    IsAny<Sub> extends true ? boolean :         // Nothing can be determined about a subset of `any`\r\n    IsAny<Super> extends true ? boolean :       // Nothing can be determined about a superset of `any`\r\n    __IsSubsetOf<Sub, Super>;\r\n\r\ntype __IsSubsetOf<Sub, Super> =\r\n    IsNever<Sub> extends true ? true :          // The empty set is a subset of all sets\r\n    IsNever<Super> extends true ? false :       // No other set is a subset of the empty set\r\n    IsUnknown<Sub> extends true ? false :       // The set of all types cannot be a proper subset of itself\r\n    IsUnknown<Super> extends true ? true :      // All other sets are the subset of the set of all types\r\n    [Sub] extends [Super] ? true :\r\n    false;\r\n\r\n/**\r\n * Maps to `true` if `Super` is a superset of `Sub`; otherwise, `false`.\r\n */\r\nexport type IsSupersetOf<Super, Sub> = IsSubsetOf<Sub, Super>;\r\n\r\n/**\r\n * Maps to `true` if `Sub` is a proper subset of `Super`; otherwise, `false`.\r\n */\r\nexport type IsProperSubsetOf<Sub, Super> =\r\n    IsAny<Sub> extends true ? boolean :         // Nothing can be determined about a subset of `any`\r\n    IsAny<Super> extends true ? boolean :       // Nothing can be determined about a superset of `any`\r\n    SameType<Sub, Super> extends true ? false : // A set cannot be a proper subset of itself\r\n    __IsSubsetOf<Sub, Super>;\r\n\r\n/**\r\n * Maps to `true` if `Super` is a proper superset of `Sub`; otherwise, `false`.\r\n */\r\nexport type IsProperSupersetOf<Super, Sub> = IsProperSubsetOf<Sub, Super>;\r\n\r\n/**\r\n * Maps to the keys of `T` whose values match `TMatch`.\r\n */\r\nexport type MatchingKeys<T, TMatch> = { [P in keyof T]: T[P] extends TMatch ? P : never }[keyof T];\r\n\r\n/**\r\n * Maps to the keys of `T` whose values do not match `TMatch`.\r\n */\r\nexport type NonMatchingKeys<T, TMatch> = Exclude<keyof T, MatchingKeys<T, TMatch>>;\r\n\r\n/**\r\n * Maps to the keys of `T` whose values are functions.\r\n */\r\nexport type FunctionKeys<T, F extends Function = Function> = MatchingKeys<T, F>;\r\n\r\n/**\r\n * Maps to the keys of `T` whose values are not functions.\r\n */\r\nexport type NonFunctionKeys<T, F extends Function = Function> = NonMatchingKeys<T, F>;\r\n\r\n/**\r\n * Maps `T` to its awaited type if `T` is a promise.\r\n */\r\nexport type Await<T> =\r\n    T extends { then(onfulfilled: infer U): any } ?\r\n        U extends ((value: infer V) => any) ?\r\n            Await<V> :\r\n            never :\r\n    T;\r\n\r\n/**\r\n * Maps each element of `T` to its awaited type if the element is a promise.\r\n */\r\nexport type AwaitAll<T extends any[]> = { [P in keyof T]: Await<T[P]>; };\r\n\r\n/**\r\n * Maps to a tuple where the first element is the first element of `L` and the second element are the remaining elements of `L`.\r\n */\r\nexport type Shift<L extends any[]> = L extends [infer H, ...infer T] ? [H, T] : [never, never];\r\n\r\n/**\r\n * Inserts an element at the start of a tuple.\r\n */\r\nexport type Unshift<T extends any[], H> = [H, ...T];\r\n\r\n/**\r\n * Reverse the order of the elements of a tuple.\r\n */\r\nexport type Reverse<L extends any[]> = L extends [infer H, ...infer T] ? [...Reverse<T>, H] : [];\r\n\r\n/**\r\n * Maps to a tuple where the first element is the last element of `L` and the second element are the remaining elements of `L`.\r\n */\r\nexport type Pop<L extends any[]> = L extends [...infer H, infer T] ? [T, H] : [never, never];\r\n\r\n/**\r\n * Push an element on to the end of a tuple.\r\n */\r\nexport type Push<H extends any[], T> = [...H, T];\r\n\r\n/**\r\n * Split an object into a union of objects for each key/value pair.\r\n */\r\nexport type Disjoin<T extends object> =\r\n    IsNever<T> extends true ? never :\r\n    IsAny<T> extends true ? any :\r\n    __DisjoinRest<{ [K in keyof T]: { [P in K]: T[P] }; }[keyof T]>;\r\n\r\ntype __DisjoinRest<T> = IsNever<T> extends true ? {} : T;\r\n\r\n/**\r\n * Map an intersection of object types into a single object type.\r\n */\r\nexport type Reshape<T extends object> = Pick<T, keyof T>;\r\n\r\n/**\r\n * Joins a union of disjoint object types into a single object type.\r\n */\r\nexport type Conjoin<T extends object> = {\r\n    [P in AnyKeyof<T>]: AnyExtract<T, { readonly [U in P]: unknown }>[P];\r\n};\r\n\r\n/**\r\n * Maps to `true` if any type in `A` is assignable to or shares a property with any type in `B`; otherwise, `false`.\r\n * This is similar to `Overlaps`, except object types in `A` and `B` are mapped through `Disjoin`.\r\n */\r\nexport type DisjoinOverlaps<A, B> = Overlaps<\r\n    A extends object ? Disjoin<A> : A,\r\n    B extends object ? Disjoin<B> : B\r\n>;\r\n\r\n/**\r\n * Maps to `true` if `T` is an empty object (`{}`).\r\n */\r\nexport type IsEmpty<T extends object> = IsNever<keyof T>;\r\n\r\n/**\r\n * Remove from `T` all keys in `K`.\r\n */\r\nexport import Omit = globalThis.Omit;\r\n\r\n/**\r\n * Remove from `A` all properties with the same types that exist in `B`.\r\n */\r\nexport type Diff<A extends object, B extends object> = Omit<A, keyof B>;\r\n\r\n/**\r\n * Pick from `A` all properties with the same types that exist in `B`.\r\n */\r\nexport type Intersect<A extends object, B extends object> = Pick<A & B, Extract<keyof A, keyof B> & Extract<keyof B, keyof A>>;\r\n\r\n/**\r\n * Combine the properties of `A` and `B`, chosing the properties in `B` if the types differ.\r\n */\r\nexport type Assign<A extends object, B extends object> = Reshape<Diff<A, B> & B>;\r\n\r\n/**\r\n * Maps to a mutable copy of T.\r\n */\r\nexport type Mutable<T> = {\r\n    -readonly [P in keyof T]: T[P];\r\n}\r\n"]}