"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.CancelError = exports.CancelableSource = exports.CancelSubscription = exports.Cancelable = void 0;
const disposable_1 = require("@esfx/disposable");
const internal_guards_1 = require("@esfx/internal-guards");
const internal_tag_1 = require("@esfx/internal-tag");
const internal_deprecate_1 = require("@esfx/internal-deprecate");
const cancelSubscriptionPrototype = (0, internal_tag_1.defineTag)(Object.setPrototypeOf({
    [disposable_1.Disposable.dispose]() {
        this.unsubscribe();
    },
}, disposable_1.Disposable.prototype), "CancelSubscription");
function createCancelSubscription(unsubscribe) {
    return Object.setPrototypeOf({
        unsubscribe() {
            unsubscribe();
        },
    }, cancelSubscriptionPrototype);
}
var Cancelable;
(function (Cancelable) {
    // #region Cancelable
    /**
     * A well-known symbol used to define a method to retrieve the `CancelSignal` for an object.
     */
    Cancelable.cancelSignal = Symbol.for("@esfx/cancelable:Cancelable.cancelSignal");
    // #endregion Cancelable
    const cancelSignalPrototype = (0, internal_tag_1.defineTag)({
        [Cancelable.cancelSignal]() {
            return this;
        }
    }, "CancelSignal");
    const emptySubscription = createCancelSubscription(() => { });
    Object.freeze(emptySubscription);
    /**
     * A `Cancelable` that is already signaled.
     */
    Cancelable.canceled = Object.setPrototypeOf({
        get signaled() {
            return true;
        },
        subscribe(onSignaled) {
            onSignaled();
            return emptySubscription;
        }
    }, cancelSignalPrototype);
    Object.freeze(Cancelable.canceled);
    /**
     * A `Cancelable` that can never be signaled.
     */
    Cancelable.none = Object.setPrototypeOf({
        get signaled() {
            return false;
        },
        subscribe(_onSignaled) {
            return emptySubscription;
        },
    }, cancelSignalPrototype);
    Object.freeze(Cancelable.none);
    /**
     * Determines whether a value is a `Cancelable` object.
     * @deprecated Use `Cancelable.hasInstance` instead.
     */
    function isCancelable(value) {
        return Cancelable.hasInstance(value);
    }
    Cancelable.isCancelable = isCancelable;
    /**
     * Determines whether `cancelable` is in the signaled state.
     */
    function isSignaled(cancelable) {
        if (!(0, internal_guards_1.isMissing)(cancelable) && !isCancelable(cancelable))
            throw new TypeError("Cancelable expected: cancelable");
        if (cancelable === Cancelable.canceled)
            return true;
        if (cancelable === Cancelable.none || (0, internal_guards_1.isMissing)(cancelable))
            return false;
        return cancelable[Cancelable.cancelSignal]().signaled;
    }
    Cancelable.isSignaled = isSignaled;
    /**
     * Throws a `CancelError` exception if the provided `cancelable` is in the signaled state.
     */
    function throwIfSignaled(cancelable) {
        if (isSignaled(cancelable)) {
            throw new CancelError();
        }
    }
    Cancelable.throwIfSignaled = throwIfSignaled;
    /**
     * Subscribes to be notified when a `cancelable` becomes signaled.
     */
    function subscribe(cancelable, onSignaled) {
        if (!(0, internal_guards_1.isMissing)(cancelable) && !isCancelable(cancelable))
            throw new TypeError("Cancelable expected: cancelable");
        if (cancelable === Cancelable.canceled)
            return Cancelable.canceled.subscribe(onSignaled);
        if (cancelable === Cancelable.none || (0, internal_guards_1.isMissing)(cancelable))
            return Cancelable.none.subscribe(onSignaled);
        return cancelable[Cancelable.cancelSignal]().subscribe(onSignaled);
    }
    Cancelable.subscribe = subscribe;
    Cancelable.name = "Cancelable";
    /**
     * Determines whether a value is a `Cancelable` object.
     */
    function hasInstance(value) {
        return (0, internal_guards_1.isObject)(value)
            && Cancelable.cancelSignal in value;
    }
    Cancelable.hasInstance = hasInstance;
})(Cancelable = exports.Cancelable || (exports.Cancelable = {}));
var CancelSubscription;
(function (CancelSubscription) {
    /**
     * Creates a `CancelSubscription` object for an `unsubscribe` callback.
     * @param unsubscribe The callback to execute when the `unsubscribe()` method is called.
     */
    function create(unsubscribe) {
        if (!(0, internal_guards_1.isFunction)(unsubscribe))
            throw new TypeError("Function expected: unsubscribe");
        return createCancelSubscription(unsubscribe);
    }
    CancelSubscription.create = create;
})(CancelSubscription = exports.CancelSubscription || (exports.CancelSubscription = {}));
var CancelableSource;
(function (CancelableSource) {
    // #region Cancelable
    CancelableSource.cancelSignal = Cancelable.cancelSignal;
    CancelableSource.isCancelable = Cancelable.isCancelable;
    // #endregion Cancelable
    // #region CancelableSource
    CancelableSource.cancel = Symbol.for("@esfx/cancelable:CancelableSource.cancel");
    // #endregion CancelableSource
    /**
     * Determines whether a value is a `CancelableSource` object.
     * @deprecated Use `CancelableSource.hasInstance` instead.
     */
    function isCancelableSource(value) {
        return CancelableSource.hasInstance(value);
    }
    CancelableSource.isCancelableSource = isCancelableSource;
    CancelableSource.name = "CancelableSource";
    /**
     * Determines whether a value is a `CancelableSource` object.
     */
    function hasInstance(value) {
        return CancelableSource.isCancelable(value)
            && CancelableSource.cancel in value;
    }
    CancelableSource.hasInstance = hasInstance;
})(CancelableSource = exports.CancelableSource || (exports.CancelableSource = {}));
class CancelError extends Error {
    constructor(message) {
        super(message || "Operation was canceled");
    }
}
exports.CancelError = CancelError;
Object.defineProperty(CancelError.prototype, "name", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: "CancelError",
});
(0, internal_deprecate_1.deprecateProperty)(Cancelable, 'isCancelable', "Use 'Cancelable.hasInstance' instead.");
(0, internal_deprecate_1.deprecateProperty)(CancelableSource, 'isCancelable', "Use 'Cancelable.hasInstance' instead.");
(0, internal_deprecate_1.deprecateProperty)(CancelableSource, 'isCancelableSource', "Use 'CancelableSource.hasInstance' instead.");
//# sourceMappingURL=index.js.map