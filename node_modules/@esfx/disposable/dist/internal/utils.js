"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   CreateScope is derived from https://github.com/mhofman/disposator/ which
   is licensed under the Apache 2.0 License:

   Copyright 2021 Mathieu Hofman

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeprecation = exports.CreateScope = exports.DisposeResources = exports.Dispose = exports.GetMethod = exports.GetDisposeMethod = exports.CreateDisposableResource = exports.AddDisposableResource = exports.Call = exports.asyncDisposeSym = exports.disposeSym = void 0;
/* @internal */
exports.disposeSym = GetSymbol("dispose", "@esfx/disposable:Disposable.dispose");
/* @internal */
exports.asyncDisposeSym = GetSymbol("asyncDispose", "@esfx/disposable:AsyncDisposable.asyncDispose");
/* @internal */
exports.Call = Function.prototype.call.bind(Function.prototype.call);
/* @internal */
function AddDisposableResource(disposableResourceStack, V, hint) {
    if (V === null || V === undefined)
        return;
    if (typeof V !== "object" && typeof V !== "function")
        throw new TypeError("Object expected");
    const resource = CreateDisposableResource(V, hint);
    disposableResourceStack[disposableResourceStack.length] = resource;
}
exports.AddDisposableResource = AddDisposableResource;
/* @internal */
function CreateDisposableResource(resource, hint) {
    const dispose = GetDisposeMethod(resource, hint);
    if (dispose === undefined) {
        if (typeof resource === "function") {
            return { hint, resource: null, dispose: resource };
        }
        throw new TypeError(hint === "async" ? "Object not async disposable" : "Object not disposable");
    }
    return { hint, resource, dispose };
}
exports.CreateDisposableResource = CreateDisposableResource;
/* @internal */
function GetDisposeMethod(resource, hint) {
    let method;
    if (hint === "async") {
        method = GetMethod(resource, exports.asyncDisposeSym);
    }
    if (method === undefined) {
        method = GetMethod(resource, exports.disposeSym);
    }
    return method;
}
exports.GetDisposeMethod = GetDisposeMethod;
/* @internal */
function GetMethod(V, P) {
    const func = V[P];
    if (func === null || func === undefined)
        return undefined;
    if (typeof func !== "function")
        throw new TypeError(`Property ${typeof P === "symbol" ? P.toString() : JSON.stringify(P)} is not a function.`);
    return func;
}
exports.GetMethod = GetMethod;
/* @internal */
function Dispose(V, hint, method) {
    return hint === "async" ? execAsync() : execSync();
    function execSync() {
        (0, exports.Call)(method, V);
    }
    async function execAsync() {
        const result = (0, exports.Call)(method, V);
        if (result !== undefined)
            await result;
    }
}
exports.Dispose = Dispose;
/* @internal */
function DisposeResources(hint, disposableResourceStack, suppress, throwCompletion, errors = []) {
    return (hint === "async" ? execAsync() : execSync());
    function execSync() {
        if (disposableResourceStack !== undefined) {
            for (let i = disposableResourceStack.length - 1; i >= 0; i--) {
                const resource = disposableResourceStack[i];
                try {
                    Dispose(resource.resource, resource.hint, resource.dispose);
                }
                catch (e) {
                    if (suppress) {
                        errors.length = 0;
                        throwCompletion = { cause: e };
                    }
                    else {
                        errors[errors.length] = e;
                    }
                }
            }
        }
        if (errors.length > 0)
            ThrowAggregateError(errors, throwCompletion, DisposeResources);
        if (throwCompletion)
            throw throwCompletion.cause;
    }
    async function execAsync() {
        if (disposableResourceStack !== undefined) {
            for (let i = disposableResourceStack.length - 1; i >= 0; i--) {
                const resource = disposableResourceStack[i];
                try {
                    const result = Dispose(resource.resource, resource.hint, resource.dispose);
                    if (result !== undefined)
                        await result;
                }
                catch (e) {
                    if (suppress) {
                        errors.length = 0;
                        throwCompletion = { cause: e };
                    }
                    else {
                        errors[errors.length] = e;
                    }
                }
            }
        }
        if (errors.length > 0)
            ThrowAggregateError(errors, throwCompletion, DisposeResources);
        if (throwCompletion)
            throw throwCompletion.cause;
    }
}
exports.DisposeResources = DisposeResources;
/* @internal */
function CreateScope(hint) {
    // Credit to Mathieu Hofman for initial `for (const { using } of Disposable)` mechanism: https://github.com/mhofman/disposator/
    // See THIRD PARTY LICENSE NOTICE at the top of this file.
    // Modified to return a `fail` callback to emulate error suppression semantics of https://github.com/tc39/proposal-explicit-resource-management/
    const context = {
        scope: Object.freeze({
            using(resource) {
                if (context.state !== "initialized")
                    throw new Error("Illegal state.");
                AddDisposableResource(context.disposables, resource, hint);
                return resource;
            },
            fail(error) {
                if (context.state !== "initialized")
                    throw new Error("Illegal state.");
                context.throwCompletion = { cause: error };
            }
        }),
        state: "initialized",
        disposables: [],
        throwCompletion: undefined,
    };
    return context;
}
exports.CreateScope = CreateScope;
function ThrowAggregateError(errors, throwCompletion, stackCrawlMark = ThrowAggregateError) {
    let error;
    if (typeof AggregateError === "function") {
        error = new AggregateError(errors);
    }
    else {
        error = new Error("One or more errors occurred");
        error.name = "AggregateError";
        error.errors = errors;
    }
    if (throwCompletion) {
        Object.defineProperty(error, "cause", { configurable: true, writable: true, value: throwCompletion.cause });
    }
    if (Error.captureStackTrace) {
        Error.captureStackTrace(error, stackCrawlMark);
    }
    throw error;
}
/* @internal */
function GetSymbol(builtInSymbolName, customSymbolName) {
    const builtInSymbol = Symbol[builtInSymbolName];
    return typeof builtInSymbol === "symbol" ? builtInSymbol : Symbol.for(customSymbolName);
}
/* @internal */
function createDeprecation(message) {
    const deprecation = () => {
        if (!deprecation.reported) {
            deprecation.reported = true;
            if (typeof process === "object" && process.emitWarning) {
                process.emitWarning(message, "DeprecationWarning", deprecation);
            }
            else if (typeof console === "object") {
                console.warn(`Deprecation: ${message}`);
            }
        }
    };
    return deprecation;
}
exports.createDeprecation = createDeprecation;
//# sourceMappingURL=utils.js.map