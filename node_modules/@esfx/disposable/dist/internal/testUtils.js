"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disableDeprecations = exports.hasOwnSetter = exports.hasOwnGetter = exports.hasOwnMethod = exports.isNonWritable = exports.isWritable = exports.isNonConfigurable = exports.isConfigurable = exports.isNonEnumerable = exports.isEnumerable = exports.isInherited = exports.isOwn = exports.isFunction = exports.isObject = void 0;
const jest_matcher_utils_1 = require("jest-matcher-utils");
/* @internal */
const isObject = (value) => typeof value === "object" && value !== null;
exports.isObject = isObject;
/* @internal */
const isFunction = (value) => typeof value === "function";
exports.isFunction = isFunction;
/* @internal */
const isOwn = (object, key) => !!Object.getOwnPropertyDescriptor(object, key);
exports.isOwn = isOwn;
/* @internal */
const isInherited = (object, key, base) => object === undefined ? false :
    object === base ? (0, exports.isOwn)(object, key) :
        (0, exports.isInherited)(Object.getPrototypeOf(object), key, base);
exports.isInherited = isInherited;
/* @internal */
const isEnumerable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.enumerable) === true; };
exports.isEnumerable = isEnumerable;
/* @internal */
const isNonEnumerable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.enumerable) === false; };
exports.isNonEnumerable = isNonEnumerable;
/* @internal */
const isConfigurable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.configurable) === true; };
exports.isConfigurable = isConfigurable;
/* @internal */
const isNonConfigurable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.configurable) === false; };
exports.isNonConfigurable = isNonConfigurable;
/* @internal */
const isWritable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.writable) === true; };
exports.isWritable = isWritable;
/* @internal */
const isNonWritable = (object, key) => { var _a; return ((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.writable) === false; };
exports.isNonWritable = isNonWritable;
/* @internal */
const hasOwnMethod = (object, key) => { var _a; return (0, exports.isFunction)((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.value); };
exports.hasOwnMethod = hasOwnMethod;
/* @internal */
const hasOwnGetter = (object, key) => { var _a; return !!((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.get); };
exports.hasOwnGetter = hasOwnGetter;
/* @internal */
const hasOwnSetter = (object, key) => { var _a; return !!((_a = Object.getOwnPropertyDescriptor(object, key)) === null || _a === void 0 ? void 0 : _a.set); };
exports.hasOwnSetter = hasOwnSetter;
function makePropertyExpectationWithBase(test, name, expectedMessage, isNegation) {
    const formatKey = (key) => typeof key === "symbol" ? key.toString() : JSON.stringify(key);
    const passMessage = (key) => () => `${(0, jest_matcher_utils_1.matcherHint)(`.not.${name}`)}\n\nExpected property ${formatKey(key)} to ${isNegation ? "" : "not "}be ${expectedMessage}.`;
    const failMessage = (key) => () => `${(0, jest_matcher_utils_1.matcherHint)(`.${name}`)}\n\nExpected property ${formatKey(key)} to ${isNegation ? "not " : ""}be ${expectedMessage}`;
    return (received, key, base) => {
        const pass = test(received, key, base);
        const message = (pass ? passMessage : failMessage)(key);
        return { pass, message };
    };
}
function makePropertyExpectation(test, name, expectedMessage, isNegation) {
    const expectation = makePropertyExpectationWithBase(test, name, expectedMessage, isNegation);
    return (received, key) => expectation(received, key);
}
expect.extend({
    toHaveInheritedProperty: makePropertyExpectationWithBase(exports.isInherited, "toHaveInheritedProperty", "an inherited property", /*isNegation*/ false),
    toHaveOwnProperty: makePropertyExpectation(exports.isOwn, "toHaveOwnProperty", "an own property", /*isNegation*/ false),
    toHaveOwnMethod: makePropertyExpectation(exports.hasOwnMethod, "toHaveOwnMethod", "an own method", /*isNegation*/ false),
    toHaveOwnGetter: makePropertyExpectation(exports.hasOwnGetter, "toHaveOwnGetter", "an own getter", /*isNegation*/ false),
    toHaveOwnSetter: makePropertyExpectation(exports.hasOwnSetter, "toHaveOwnSetter", "an own setter", /*isNegation*/ false),
    toHaveWritableProperty: makePropertyExpectation(exports.isWritable, "toHaveWritableProperty", "writable", /*isNegation*/ false),
    toHaveNonWritableProperty: makePropertyExpectation(exports.isNonWritable, "toHaveNonWritableProperty", "writable", /*isNegation*/ true),
    toHaveEnumerableProperty: makePropertyExpectation(exports.isEnumerable, "toHaveEnumerableProperty", "enumerable", /*isNegation*/ false),
    toHaveNonEnumerableProperty: makePropertyExpectation(exports.isNonEnumerable, "toHaveNonEnumerableProperty", "enumerable", /*isNegation*/ true),
    toHaveConfigurableProperty: makePropertyExpectation(exports.isConfigurable, "toHaveConfigurableProperty", "configurable", /*isNegation*/ false),
    toHaveNonConfigurableProperty: makePropertyExpectation(exports.isNonConfigurable, "toHaveNonConfigurableProperty", "configurable", /*isNegation*/ true),
    toBeTypeof(received, typeTag) {
        const receivedTypeTag = typeof received;
        const pass = receivedTypeTag === typeTag;
        const message = pass ?
            () => `${(0, jest_matcher_utils_1.matcherHint)(".not.toBeTypeof")}\n\nExpected typeof value to not be ${(0, jest_matcher_utils_1.printExpected)(typeTag)}.` :
            () => `${(0, jest_matcher_utils_1.matcherHint)(".toBeTypeof")}\n\nExpected typeof value to be ${(0, jest_matcher_utils_1.printExpected)(typeTag)}, but it was ${(0, jest_matcher_utils_1.printReceived)(typeTag)} instead.`;
        return { pass, message };
    }
});
function disableDeprecations(deprecations) {
    beforeEach(() => {
        const reports = deprecations.map(dep => dep.reported);
        for (const dep of deprecations) {
            dep.reported = true;
        }
        afterEach(() => {
            for (let i = 0; i < reports.length; i++) {
                deprecations[i].reported = reports[i];
            }
        });
    });
}
exports.disableDeprecations = disableDeprecations;
//# sourceMappingURL=testUtils.js.map