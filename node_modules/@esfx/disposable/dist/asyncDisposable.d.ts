/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
import { Disposable } from "./disposable";
/**
 * Indicates an object that has resources that can be explicitly disposed asynchronously.
 */
export interface AsyncDisposable {
    /**
     * Dispose this object's resources.
     */
    [AsyncDisposable.asyncDispose](): Promise<void>;
}
export declare type AsyncDisposableLike = AsyncDisposable | Disposable | (() => void | PromiseLike<void>);
/**
 * Indicates an object that has resources that can be explicitly disposed asynchronously.
 *
 * NOTE: It is not necessary to subclass `Disposable`. Merely having a `[Disposable.dispose]()` method is sufficient.
 */
export declare class AsyncDisposable {
    /**
     * A well-known symbol used to define an async explicit resource disposal method on an object.
     *
     * Uses `Symbol.asyncDispose` if present.
     */
    static readonly asyncDispose: unique symbol;
    /**
     * Creates an `AsyncDisposable` wrapper around a callback used to dispose resources.
     */
    constructor(onDispose: () => void | PromiseLike<void>);
    /**
     * Creates an `AsyncDisposable` wrapper around a set of other disposables.
     * @param resources An `Iterable` of `AsyncDisposable` or `Disposable` objects.
     * @deprecated Use `new AsyncDisposableStack` and `AsyncDisposableStack.prototype.use()` instead. Creating a disposable object from an array is
     * considered unsafe, as an exception raised when allocating a later disposable could result in an earlier disposable not being disposed:
     * ```js
     * AsyncDisposable.from([getResourceX(), getResourceY()])
     * //                    ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^
     * //                    |               |
     * //                    allocated, but  throws
     * //                    not disposed
     * ```
     */
    static from(resources: AsyncIterable<AsyncDisposableLike | null | undefined> | Iterable<AsyncDisposableLike | null | undefined | PromiseLike<AsyncDisposableLike | null | undefined>>): Promise<AsyncDisposable>;
    /**
     * Emulate `using await const` using `for..await..of`.
     *
     * @example
     * ```ts
     * // with `using await const` (proposed)
     * {
     *   ...
     *   using await const x = expr, y = expr;
     *   ...
     * }
     *
     * // with `AsyncDisposable.scope()`:
     * for await (const { using, fail } of AsyncDisposable.scope()) {
     *   try {
     *     ...
     *     const x = using(expr), y = using(expr);
     *     ...
     *   }
     *   catch (e) {
     *     fail(e);
     *   }
     * }
     * ```
     */
    static scope(): AsyncGenerator<AsyncDisposableScope, void, undefined>;
    /**
     * Yields each disposable in the iterable, disposing it when the generator resumes.
     *
     * This emulates `for (using await const x of expr)`.
     *
     * @example
     * ```ts
     * // with `using await const` (proposed)
     * for (using await const x of expr) {
     *   ...
     * }
     * for await (using await const x of expr) {
     *   ...
     * }
     *
     * // with `Disposable.usingEach()`:
     * for await (const x of Disposable.usingEach(expr)) {
     *   ...
     * }
     * ```
     */
    static usingEach(iterable: AsyncIterable<AsyncDisposableLike | null | undefined> | Iterable<AsyncDisposableLike | null | undefined | PromiseLike<AsyncDisposableLike | null | undefined>>): AsyncGenerator<AsyncDisposableLike | null | undefined, void, unknown>;
    /**
     * Executes a callback with the provided `AsyncDisposable` resource, disposing the resource when the callback completes asynchronously.
     * @deprecated Use `AsyncDisposable.scope()` instead.
     */
    static use<T extends AsyncDisposableLike | null | undefined, U>(resource: T, callback: (resource: T) => U | PromiseLike<U>): Promise<U | undefined>;
    /**
     * Determines whether a value is `AsyncDisposable`.
     */
    static hasInstance(value: unknown): value is AsyncDisposable;
    /**
     * Determines whether a value is `AsyncDisposable`.
     */
    static [Symbol.hasInstance](value: unknown): value is AsyncDisposable;
}
export declare namespace AsyncDisposable {
    /**
     * Creates an `AsyncDisposable` wrapper around a callback used to dispose resources.
     * @deprecated Use `new AsyncDisposable(dispose)` instead.
     */
    function create(dispose: () => void | PromiseLike<void>): AsyncDisposable;
}
export interface AsyncDisposableScope {
    /**
     * Tracks a resource to be disposed at the end of a `for..of` statement. See {@link AsyncDisposable.scope}.
     */
    using<T extends AsyncDisposableLike | null | undefined>(value: T): T;
    /**
     * Tracks an exception from the body of a `for..of` statement. See {@link AsyncDisposable.scope}.
     */
    fail(error: unknown): void;
}
//# sourceMappingURL=asyncDisposable.d.ts.map