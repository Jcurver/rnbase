"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.__AsyncDisposable_prototype__ = exports.AsyncDisposable = exports.reportAsyncDisposableFromDeprecation = exports.reportAsyncDisposableUseDeprecation = exports.reportAsyncDisposableCreateDeprecation = void 0;
const asyncDisposable_1 = require("./internal/asyncDisposable");
const utils_1 = require("./internal/utils");
/* @internal */
exports.reportAsyncDisposableCreateDeprecation = (0, utils_1.createDeprecation)("Use 'new AsyncDisposable(dispose)' instead.");
/* @internal */
exports.reportAsyncDisposableUseDeprecation = (0, utils_1.createDeprecation)("Use 'AsyncDisposable.scope()' instead.");
/* @internal */
exports.reportAsyncDisposableFromDeprecation = (0, utils_1.createDeprecation)("'AsyncDisposable.from()' is unsafe. Use 'new AsyncDisposableStack' and 'AsyncDisposableStack.prototype.use' instead.");
/**
 * Indicates an object that has resources that can be explicitly disposed asynchronously.
 *
 * NOTE: It is not necessary to subclass `Disposable`. Merely having a `[Disposable.dispose]()` method is sufficient.
 */
class AsyncDisposable {
    /**
     * Creates an `AsyncDisposable` wrapper around a callback used to dispose resources.
     */
    constructor(onDispose) {
        if (typeof onDispose !== "function")
            throw new TypeError("Function expected: dispose");
        asyncDisposable_1.weakAsyncDisposableState.set(this, "pending-one");
        asyncDisposable_1.weakAsyncDisposableResourceStack.set(this, [{ hint: "async", resource: null, dispose: onDispose }]);
    }
    /* @internal */
    async [utils_1.asyncDisposeSym]() {
        const disposableState = asyncDisposable_1.weakAsyncDisposableState.get(this);
        if (disposableState === "disposed")
            return;
        if (disposableState !== "pending" && disposableState !== "pending-one")
            throw new TypeError("Wrong target");
        asyncDisposable_1.weakAsyncDisposableState.set(this, "disposed");
        await (0, utils_1.DisposeResources)("async", asyncDisposable_1.weakAsyncDisposableResourceStack.get(this), disposableState === "pending-one", /*completion*/ undefined);
    }
    /**
     * Creates an `AsyncDisposable` wrapper around a set of other disposables.
     * @param resources An `Iterable` of `AsyncDisposable` or `Disposable` objects.
     * @deprecated Use `new AsyncDisposableStack` and `AsyncDisposableStack.prototype.use()` instead. Creating a disposable object from an array is
     * considered unsafe, as an exception raised when allocating a later disposable could result in an earlier disposable not being disposed:
     * ```js
     * AsyncDisposable.from([getResourceX(), getResourceY()])
     * //                    ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^
     * //                    |               |
     * //                    allocated, but  throws
     * //                    not disposed
     * ```
     */
    static async from(resources) {
        (0, exports.reportAsyncDisposableFromDeprecation)();
        const disposableResourceStack = [];
        const errors = [];
        let throwCompletion;
        try {
            for await (const resource of resources) {
                try {
                    (0, utils_1.AddDisposableResource)(disposableResourceStack, resource, "async");
                }
                catch (e) {
                    errors.push(e);
                }
            }
        }
        catch (e) {
            throwCompletion = { cause: e };
        }
        finally {
            if (errors.length || throwCompletion) {
                await (0, utils_1.DisposeResources)("async", disposableResourceStack, /*suppress*/ false, throwCompletion, errors);
            }
        }
        const disposable = Object.create(exports.__AsyncDisposable_prototype__);
        asyncDisposable_1.weakAsyncDisposableState.set(disposable, "pending");
        asyncDisposable_1.weakAsyncDisposableResourceStack.set(disposable, disposableResourceStack);
        return disposable;
    }
    /**
     * Emulate `using await const` using `for..await..of`.
     *
     * @example
     * ```ts
     * // with `using await const` (proposed)
     * {
     *   ...
     *   using await const x = expr, y = expr;
     *   ...
     * }
     *
     * // with `AsyncDisposable.scope()`:
     * for await (const { using, fail } of AsyncDisposable.scope()) {
     *   try {
     *     ...
     *     const x = using(expr), y = using(expr);
     *     ...
     *   }
     *   catch (e) {
     *     fail(e);
     *   }
     * }
     * ```
     */
    static async *scope() {
        const context = (0, utils_1.CreateScope)("async");
        try {
            context.state = "initialized";
            yield context.scope;
            context.state = "exiting";
        }
        finally {
            context.state = "done";
            await (0, utils_1.DisposeResources)("async", context.disposables, /*suppress*/ false, context.throwCompletion);
        }
    }
    /**
     * Yields each disposable in the iterable, disposing it when the generator resumes.
     *
     * This emulates `for (using await const x of expr)`.
     *
     * @example
     * ```ts
     * // with `using await const` (proposed)
     * for (using await const x of expr) {
     *   ...
     * }
     * for await (using await const x of expr) {
     *   ...
     * }
     *
     * // with `Disposable.usingEach()`:
     * for await (const x of Disposable.usingEach(expr)) {
     *   ...
     * }
     * ```
     */
    static async *usingEach(iterable) {
        for await (const disposable of iterable) {
            for await (const { using, fail } of AsyncDisposable.scope())
                try {
                    yield using(disposable);
                }
                catch (e) {
                    fail(e);
                }
        }
    }
    /**
     * Executes a callback with the provided `AsyncDisposable` resource, disposing the resource when the callback completes asynchronously.
     * @deprecated Use `AsyncDisposable.scope()` instead.
     */
    static async use(resource, callback) {
        (0, exports.reportAsyncDisposableUseDeprecation)();
        for await (const { using, fail } of AsyncDisposable.scope()) {
            try {
                return callback(using(resource));
            }
            catch (e) {
                fail(e);
            }
        }
    }
    /**
     * Determines whether a value is `AsyncDisposable`.
     */
    static hasInstance(value) {
        return typeof value === "object"
            && value !== null
            && utils_1.asyncDisposeSym in value;
    }
    /**
     * Determines whether a value is `AsyncDisposable`.
     */
    static [Symbol.hasInstance](value) {
        return AsyncDisposable.hasInstance(value);
    }
}
exports.AsyncDisposable = AsyncDisposable;
/**
 * A well-known symbol used to define an async explicit resource disposal method on an object.
 *
 * Uses `Symbol.asyncDispose` if present.
 */
AsyncDisposable.asyncDispose = utils_1.asyncDisposeSym;
/* @internal */
exports.__AsyncDisposable_prototype__ = AsyncDisposable.prototype;
Object.defineProperty(exports.__AsyncDisposable_prototype__, Symbol.toStringTag, { configurable: true, value: "AsyncDisposable" });
Object.defineProperty(AsyncDisposable, Symbol.hasInstance, Object.getOwnPropertyDescriptor(AsyncDisposable, "hasInstance"));
(function (AsyncDisposable) {
    /**
     * Creates an `AsyncDisposable` wrapper around a callback used to dispose resources.
     * @deprecated Use `new AsyncDisposable(dispose)` instead.
     */
    function create(dispose) {
        (0, exports.reportAsyncDisposableCreateDeprecation)();
        return new AsyncDisposable(dispose);
    }
    AsyncDisposable.create = create;
})(AsyncDisposable = exports.AsyncDisposable || (exports.AsyncDisposable = {}));
//# sourceMappingURL=asyncDisposable.js.map