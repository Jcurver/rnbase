"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var chalk_1 = __importDefault(require("chalk"));
var plur_1 = __importDefault(require("plur"));
var path_1 = require("path");
var SEPARATOR = '\n';
var WARNING = 'Warning';
var ERROR = 'Error';
var isError = function (severity) { return severity === 2; };
var pad = function (str, minLen, maxLen) {
    return maxLen <= minLen ? str : "" + str + ' '.repeat(maxLen - minLen);
};
var buildPath = function (filePath, line, column) {
    var path = !filePath.includes('/') && !filePath.includes('\\')
        ? "." + path_1.sep + filePath
        : filePath;
    return [path, line ? ":" + line : '', column ? ":" + column : ''].join('');
};
var getErrorType = function (severity, isRaw) {
    if (isRaw === void 0) { isRaw = true; }
    if (isRaw) {
        return (isError(severity) ? ERROR : WARNING) + ": ";
    }
    return (isError(severity) ? chalk_1.default.red(ERROR) : chalk_1.default.blue(WARNING)) + ": ";
};
var buildMessage = function (_a, maxPathLen, maxRuleLen) {
    var errorType = _a.errorType, message = _a.message, rule = _a.rule, path = _a.path;
    return "" + errorType + pad(path.filePath, path.len, maxPathLen) + " " + pad(rule.name, rule.len, maxRuleLen) + " " + message;
};
var buildOutput = function (result) {
    var initialData = {
        maxRuleLen: 0,
        maxPathLen: 0,
        messages: [],
    };
    var _a = result.messages.reduce(function (_a, _b) {
        var maxRuleLen = _a.maxRuleLen, maxPathLen = _a.maxPathLen, messages = _a.messages;
        var severity = _b.severity, message = _b.message, ruleId = _b.ruleId, column = _b.column, line = _b.line;
        var errorType = getErrorType(severity);
        var path = buildPath(result.filePath, line, column);
        var ruleName = ruleId ? ruleId : '';
        var ruleLen = ruleName.length;
        var pathLen = errorType.length + path.length;
        return {
            maxRuleLen: Math.max(maxRuleLen, ruleLen),
            maxPathLen: Math.max(maxPathLen, pathLen),
            messages: __spreadArrays(messages, [
                {
                    errorType: getErrorType(severity, false),
                    message: chalk_1.default.yellow(message),
                    rule: { name: chalk_1.default.grey(ruleName), len: ruleLen },
                    path: { filePath: path, len: pathLen },
                },
            ]),
        };
    }, initialData), maxRuleLen = _a.maxRuleLen, maxPathLen = _a.maxPathLen, messages = _a.messages;
    return __spreadArrays([
        chalk_1.default.white(result.filePath)
    ], messages.map(function (message) { return buildMessage(message, maxPathLen, maxRuleLen); })).join(SEPARATOR);
};
module.exports = function (results) {
    var resultsLen = results.length;
    var output = [];
    var meta = [];
    var warningCount = 0;
    var errorCount = 0;
    for (var i = 0; i < resultsLen; i++) {
        var result = results[i];
        if (result.warningCount || result.errorCount) {
            warningCount = warningCount + result.warningCount;
            errorCount = errorCount + result.errorCount;
            output.push(buildOutput(result));
        }
    }
    if (warningCount || errorCount) {
        meta.push(SEPARATOR);
    }
    if (warningCount) {
        meta.push(chalk_1.default.blue(warningCount + " " + plur_1.default('warning', warningCount)));
    }
    if (errorCount) {
        meta.push(chalk_1.default.red(errorCount + " " + plur_1.default('error', errorCount)));
    }
    return "" + output.join(SEPARATOR) + meta.join(SEPARATOR);
};
